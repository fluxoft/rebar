<?php

namespace Fluxoft\Rebar\Db;

use Fluxoft\Rebar\Db\Exceptions\InvalidModelException;
use Fluxoft\Rebar\Db\Exceptions\MapperException;
use Fluxoft\Rebar\Model as RebarModel;
use PDO;

/**
 * Class GenericMapper
 * This class is a generic database mapper, meant to be extended by a specific mapper for a
 * specific database server, e.g. MySQLMapper, SQLiteMapper, etc. However, for very simple
 * applications, this class can be used directly.
 *
 * There should be a mapper for each model in the application. The mapper is responsible for
 * CRUD operations on the model. Generally speaking, the mapper should be the only place in
 * the application where SQL is written (if the automatically-generated SQL isn't sufficient).
 *
 * @package Fluxoft\Rebar\Db
 */
abstract class GenericMapper {
	/** @var MapperFactory */
	protected MapperFactory $mapperFactory;
	/** @var RebarModel */
	protected RebarModel $model;
	/** @var PDO */
	protected PDO $reader;
	/** @var PDO */
	protected PDO $writer;

	// The following can be overridden in the extending class if the SQL needs to be customized.
	// For example, say you have a table called "users" with columns "id", "username", and "password".
	// The default SQL generated by the GenericMapper would be:
	// SELECT `users`.`id` AS `Id`, `users`.`username` AS `Username`, `users`.`password` AS `Password` FROM `users`
	// This SQL would be generated by the getSelect() method.
	// If, however, your model has a property called NumberOfLogins, which is calculated by a window function
	// that uses a JOIN to user_logins, you would override the $selectSql property like so:
	// protected string $selectSql =
	// 	 'SELECT
	//		`users`.`id` AS `Id`,
	// 		`users`.`username` AS `Username`,
	// 		`users`.`password` AS `Password`,
	// 		COUNT(`user_logins`.`id`) OVER (PARTITION BY `users`.`id`) AS `NumberOfLogins`
	// 	 FROM `users`
	//	 LEFT JOIN `user_logins` ON `users`.`id` = `user_logins`.`user_id`';
	// This would then be used in the getSelect() method.
	/** @var string */
	protected string $selectSql;
	protected string $countSql;

	// The following properties should be overridden in the extending class.
	// For example in a UserMapper class:
	// protected string $dbTable = 'users';
	// protected string $idProperty = 'Id';
	// protected array $propertyDbMap = [
	//     'Id' => 'id',
	//     'Username' => 'username',
	//     'Password' => 'password'
	// ];
	protected string $dbTable;
	protected string $idProperty;
	protected array $propertyDbMap;


	/**
	 * GenericMapper constructor.
	 * @param MapperFactory $mapperFactory
	 * @param RebarModel $model
	 * @param PDO $reader
	 * @param PDO|null $writer
	 */
	public function __construct(
		MapperFactory $mapperFactory,
		RebarModel    $model,
		PDO           $reader,
		PDO           $writer = null
	) {
		$this->mapperFactory = $mapperFactory;
		$this->model         = $model;
		$this->reader        = $reader;
		$this->writer        = $writer ?? $reader;

		foreach ($this->propertyDbMap as $property => &$dbMap) {
			// A propertyDbMap could just be set to the column name, in which case we need
			// to set it to an array with the column name as the 'column' key and a default
			// type of \PDO::PARAM_STR.
			if (!is_array($dbMap)) {
				$dbMap = ['column' => $dbMap, 'type' => \PDO::PARAM_STR];

				$this->propertyDbMap[$property] = $dbMap;
			}
		}
	}

	public function GetNew(): RebarModel {
		return clone $this->model;
	}

	/**
	 * @param  int $id
	 * @return RebarModel|null
	 * @throws MapperException
	 */
	public function GetOneById(int $id): ?RebarModel {
		$select = $this->getSelect(
			[new Filter($this->propertyDbMap[$this->idProperty]['column'], '=', $id)]
		);

		$stmt = $this->reader->prepare($select['sql']);
		$stmt->execute($select['params']);
		$row = $stmt->fetch(PDO::FETCH_ASSOC);
		if ($row) {
			$model = $this->getModel($row);
		} else {
			return null;
		}
	}

	/**
	 * @param array $filters
	 * @return RebarModel|null
	 * @throws MapperException
	 */
	public function GetOne(array $filters): ?RebarModel {
		$set = $this->GetSet($filters, [], 1, 1);
		if (count($set) > 0) {
			return $set[0];
		} else {
			return null;
		}
	}

	/**
	 * @param array $filters
	 * @param array $sort
	 * @param int $page
	 * @param int $pageSize
	 * @return RebarModel[]
	 * @throws MapperException
	 */
	public function GetSet(
		array $filters = [],
		array $sort = [],
		int   $page = 1,
		int   $pageSize = 0
	): array {
		$select = $this->getSelect($filters, $sort, $page, $pageSize);
		$stmt   = $this->reader->prepare($select['sql']);
		$stmt->execute($select['params']);
		$rows = $stmt->fetchAll(PDO::FETCH_ASSOC);
		return $this->getModelSet($rows);
	}

	/**
	 * @param array $filters
	 * @return int
	 */
	public function Count(array $filters = []): int {
		$count = $this->countSelect($filters);
		$stmt  = $this->reader->prepare($count['sql']);
		$stmt->execute($count['params']);
		$row = $stmt->fetch(PDO::FETCH_ASSOC);
		return (int) $row['count'];
	}

	/**
	 * @param RebarModel $model
	 */
	public function Delete(RebarModel &$model): void {
		$sql  = 'DELETE FROM `'.$this->dbTable.'` WHERE `'.$this->idField.'` = :id';
		$stmt = $this->writer->prepare($sql);
		$stmt->execute([$this->propertyDbMap[$this->idProperty]['column'] => $model->GetId()]);
		$model = null;
	}

	/**
	 * @param int $id
	 * @throws MapperException
	 */
	public function DeleteById(int $id): void {
		$model = $this->GetOneById($id);
		if ($model) {
			$this->Delete($model);
		}
	}

	/**
	 * @param array $filters
	 * @throws MapperException
	 */
	public function DeleteOneWhere(array $filters): void {
		$model = $this->GetOne($filters);
		if ($model) {
			$this->Delete($model);
		}
	}

	protected function create(RebarModel $model): void {
		if (!$model->IsValid()) {
			throw new InvalidModelException('Model failed validation check');
		}
		// merge properties and modified properties so everything is included in the INSERT
		$merged = array_replace_recursive(
			$model->GetProperties(),
			$model->GetModifiedProperties()
		);
		$cols   = [];
		$types  = [];
		$values = [];
		foreach ($merged as $property => $value) {
			if ($property !== $this->idProperty && !is_null($value) && isset($this->propertyDbMap[$property])) {
				$cols[]  = $this->propertyDbMap[$property]['column'];
				$types[] = $this->propertyDbMap[$property]['type'];

				$values[$this->propertyDbMap[$property]['column']] = $value;
			}
		}
		$sql  = "INSERT INTO `{$this->dbTable}` (".
			implode(', ', array_map(fn($col) => "`$col`", $cols)).
			') VALUES ('.
			implode(', ', array_map(fn($col) => ":$col", $cols)).
			')';
		$stmt = $this->writer->prepare($sql);
		$stmt->execute($values);
		$model[$this->propertyDbMap[$this->idProperty]] = $this->writer->lastInsertId();
	}

	/**
	 * @param Filter[] $filters Array of Filter objects
	 * @param array $sort Array of property names to sort by in the order they should be applied,
	 *                    e.g. ['Name', 'ID DESC']
	 * @param int $page
	 * @param int $pageSize
	 * @return array{sql: string, params: array}
	 * @throws MapperException
	 */
	protected function getSelect(
		array $filters = [],
		array $sort = [],
		int $page = 1,
		int $pageSize = 0
	): array {
		if (!isset($this->selectSql)) {
			$fields = [];
			foreach ($this->propertyDbMap as $property => $dbMap) {
				$fields[] = "`{$this->dbTable}`.`{dbMap['column']}` AS `$property`";
			}
			$this->selectSql = 'SELECT '.implode(', ', $fields).' FROM `'.$this->dbTable.'`';
		}

		$sql    = $this->selectSql;
		$filter = $this->getFilter($filters);
		$params = [];
		if (!empty($filter['sql'])) {
			$sql   .= $filter['sql'];
			$params = $filter['params'];
		}
		// Apply order, if set.
		if (!empty($sort)) {
			$orderBy = [];
			foreach ($sort as $item) {
				$itemBits = explode(' ', $item);
				$field    = $itemBits[0];
				$order    = (isset($itemBits[1]) && strtolower($itemBits[1]) === 'desc') ? 'DESC' : 'ASC';
				if (array_key_exists($field, $this->model->GetProperties())) {
					$orderBy[] = "`$field` $order";
				}
			}
			if (!empty($orderBy)) {
				$sql .= ' ORDER BY '.implode(', ', $orderBy);
			}
		}

		// Apply limit, if limited.
		if ($pageSize > 0) {
			$sql .= ' LIMIT :pageSize OFFSET :offset';

			$params['pageSize'] = $pageSize;
			$params['offset']   = $pageSize * ($page - 1);
		}
		return [
			'sql' => $sql,
			'params' => $params
		];
	}

	/**
	 * @throws MapperException
	 */
	protected function countSelect(array $filters = []): array {
		if (!isset($this->countSql)) {
			$this->countSql = 'SELECT COUNT('.
				$this->propertyDbMap[$this->idProperty]['column'].
				') AS count FROM `'.$this->dbTable.'`';
		}
		$sql    = $this->countSql;
		$filter = $this->getFilter($filters);
		$params = [];
		if (!empty($filter['sql'])) {
			$sql   .= $filter['sql'];
			$params = $filter['params'];
		}
		return [
			'sql'    => $sql,
			'params' => $params
		];
	}

	/**
	 * @param Filter[] $filters
	 * @return array{sql: string, params: array}
	 *    sql: The WHERE clause of the SQL statement
	 *    params: The parameters to bind to the SQL statement
	 * @throws MapperException
	 */
	protected function getFilter(array $filters = []): array {
		$properties    = $this->model->GetProperties();
		$params        = [];
		$whereFilters  = [];
		$havingFilters = [];
		$filterString  = '';

		// Apply filters, if provided.
		if (!empty($filters)) {
			// Get the operator and value for each filter.
			foreach ($filters as $filter) {
				switch (strtoupper($filter->Operator)) {
					case 'IN':
						$placeholders = [];
						foreach ($filter->Value as $phKey => $value) {
							$placeholder    = ":{$filter->Property}_$phKey";
							$placeholders[] = $placeholder;

							$params[$placeholder] = $value;
						}
						$filterSql = "$filter->Property IN (".implode(', ', $placeholders).")";
						break;
					case 'BETWEEN':
						$filterSql = "$filter->Property BETWEEN :{$filter->Property}_min AND :{$filter->Property}_max";

						$params["{$filter->Property}_min"] = $filter->Value[0];
						$params["{$filter->Property}_max"] = $filter->Value[1];
						break;
					default:
						$filterSql = "$filter->Operator :$filter->Property";

						$params[$filter->Property] = $filter->Value;
						break;
				}

				// If this property is in the propertyDbMap, this should be part of the WHERE clause
				if (isset($this->propertyDbMap[$filter->Property])) {
					$whereFilters[] = "`{$this->dbTable}`.`{$this->propertyDbMap[$filter->Property]['column']}` $filterSql";
				}
				// If not in propertyDbMap but in the model properties, this may be a calculated field, so add to HAVING
				elseif (isset($properties[$filter->Property])) {
					$havingFilters[] = "`$filter->Property` $filterSql";
				}
				// If not in either, this is an error.
				else {
					throw new MapperException(sprintf(
						'Trying to filter on a non-property: %s',
						$filter->Property
					));
				}
			}
		}
		if (!empty($whereFilters)) {
			$filterString = ' WHERE '.implode(' AND ', $whereFilters);
		}
		if (!empty($havingFilters)) {
			$filterString .= ' HAVING '.implode(' AND ', $havingFilters);
		}
		return [
			'sql'    => $filterString,
			'params' => $params
		];
	}

	/**
	 * @param array $initialProperties
	 * @return RebarModel
	 */
	protected function getModel(array $initialProperties = []): RebarModel {
		$model = $this->GetNew();
		$model->InitializeProperties($initialProperties);
		return $model;
	}

	/**
	 * @param array $initialPropertiesSet
	 * @return RebarModel[]
	 */
	protected function getModelSet(array $initialPropertiesSet): array {
		$models = [];
		foreach ($initialPropertiesSet as $initialProperties) {
			$models[] = $this->getModel($initialProperties);
		}
		return $models;
	}
}
